#include <unistd.h>   
#include <stdio.h>   
#include <stdlib.h>   
#include <fcntl.h>   
#include <string.h>   
#include <linux/fb.h>   
#include <sys/mman.h>   
#include <sys/ioctl.h>   
#include <arpa/inet.h>   
#include "camera.h"
#include "M0.h"
#define WORD_DATA_WIDTH     12          //字模列数                 
#define WORD_DATA_HEIGTH    16*3        //字模行数                 
#define BIT_WIDTH           8           //数据位                   
#define WORD_WIDTH          InfoHead.ciWidth - WORD_DATA_WIDTH * 8 
//汉字显示区域列起始点                                    
//#define WORD_HEIGTH         InfoHead.ciHeight - WORD_DATA_HEIGTH   
//         //汉字显示区域行起始点                                    
//
//14byte文件头   
extern Display display;

typedef struct  
{  
    char cfType[2];//文件类型，"BM"(0x4D42)   
    long cfSize;//文件大小（字节）   
    long cfReserved;//保留，值为0   
    long cfoffBits;//数据区相对于文件头的偏移量（字节）   
}__attribute__((packed)) BITMAPFILEHEADER;  
//__attribute__((packed))的作用是告诉编译器取消结构在编译过程中的优化对齐   

//40byte信息头   
typedef struct  
{  
    char ciSize[4];//BITMAPFILEHEADER所占的字节数   
    long ciWidth;//宽度   
    long ciHeight;//高度   
    char ciPlanes[2];//目标设备的位平面数，值为1   
    int ciBitCount;//每个像素的位数   
    char ciCompress[4];//压缩说明   
    char ciSizeImage[4];//用字节表示的图像大小，该数据必须是4的倍数   
    char ciXPelsPerMeter[4];//目标设备的水平像素数/米   
    char ciYPelsPerMeter[4];//目标设备的垂直像素数/米   
    char ciClrUsed[4]; //位图使用调色板的颜色数   
    char ciClrImportant[4]; //指定重要的颜色数，当该域的值等于颜色数时（或者等于0时），表示所有颜色都一样重要   
}__attribute__((packed)) BITMAPINFOHEADER;  

typedef struct  
{  
    // expected identifier or ‘(’ before ‘return’
    //lcd3.c:213:1: error: expected identifier or ‘(’ before ‘}’ token
unsigned char blue;  
unsigned char green;  
unsigned char red;  
//    unsigned char reserved;  
}__attribute__((packed)) PIXEL;//颜色模式RGB   

BITMAPFILEHEADER FileHead;  
BITMAPINFOHEADER InfoHead;  

static char *fbp = 0;  
static int xres = 0;  
static int yres = 0;  
static int bits_per_pixel = 0;  

int show_bmp();  
int update_word(int m0_tem, int m0_hum, int m0_lig);
void show_info(void);

void *init_lcd(void *args)  
{  
    sleep(1);	//延迟lcd初始化启动，优先让camera初始化并运行采集画面
    pthread_detach(pthread_self()); //分离线程
    int fbfd = 0; 
    struct fb_var_screeninfo vinfo;  
    struct fb_fix_screeninfo finfo;  
    long int screensize = 0;  
    struct fb_bitfield red;  
    struct fb_bitfield green;  
    struct fb_bitfield blue;  

    //打开显示设备   
    fbfd = open("/dev/fb0", O_RDWR);  
    if (!fbfd)  
    {  
	printf("Error: cannot open framebuffer device.\n");  
	exit(1);  
    }  

    if (ioctl(fbfd, FBIOGET_FSCREENINFO, &finfo))  
    {  
	printf("Error：reading fixed information.\n");  
	exit(2);  
    }  

    if (ioctl(fbfd, FBIOGET_VSCREENINFO, &vinfo))  
    {  
	printf("Error: reading variable information.\n");  
	exit(3);  
    }  

    printf("R:%d,G:%d,B:%d \n", vinfo.red, vinfo.green, vinfo.blue );  
    printf("%dx%d, %dbpp\n", vinfo.xres, vinfo.yres, vinfo.bits_per_pixel );  
    printf("%dx%d\n",vinfo.yres_virtual,vinfo.yres_virtual);

    xres = vinfo.xres_virtual;  
    yres = vinfo.yres_virtual;  
    bits_per_pixel = vinfo.bits_per_pixel;  

    printf("bits_per_pixel=%d\n",bits_per_pixel);
    //	  bits_per_pixel = 24;  

    //计算屏幕的总大小（字节）   
    screensize = vinfo.xres_virtual * vinfo.yres_virtual * vinfo.bits_per_pixel / 8;  
    printf("screensize=%ld byte\n",screensize);  

    //对象映射   
    fbp = (char *)mmap(0, screensize, PROT_READ | PROT_WRITE, MAP_SHARED, fbfd, 0);  
    if ((int)fbp == -1)  
    {  
	printf("Error: failed to map framebuffer device to memory.\n");  
	exit(4);  
    }  

    printf("sizeof file header=%d\n", sizeof(BITMAPFILEHEADER));  

    printf("into show_bmp function\n");  

    show_bmp();   
    //删除对象映射   
    munmap(fbp, screensize);  
    close(fbfd);  
    return 0; 
}  

int show_bmp()  
{  
    int rc;  
    int line_x, line_y;  
    long int location = 0, BytesPerLine = 0;  
    int pic_num = 0;
    

    InfoHead.ciWidth =640;
    InfoHead.ciHeight =480;
    printf("ready ok\n");
     
    while(1)
    {
	update_word(display.tmp, display.hum, display.lig);
	show_info();

	line_x = line_y = 0;  
	int read_data = 640*480;
	sem_wait(&sem_lcd);
	char *pix = bufdata;
	while(--read_data)  
	{  


	    location = line_x * bits_per_pixel / 8 + (InfoHead.ciHeight - line_y - 1) * xres * bits_per_pixel / 8;          //显示每一个像素   
	    *(fbp + location + 0)=*pix++;
	    *(fbp + location + 1)=*pix++;  
	    *(fbp + location + 2)=*pix++;  
	    *(fbp + location + 3)=0xff;  
	    line_x++;  
	    if (line_x == InfoHead.ciWidth )  
	    {  
		line_x = 0;  
		line_y++;  
		if(line_y == InfoHead.ciHeight)  
		    break;  
	    }
	} 
	//释放camera访问信号量
	sem_post(&sem_camera);
    }
    return 0;  
}  

unsigned char word_all[10][16] = {
    {0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18,0x00,0x00},	//0
    {0x00,0x00,0x00,0x10,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00},	//1
    {0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x04,0x04,0x08,0x10,0x20,0x42,0x7E,0x00,0x00},	//2
    {0x00,0x00,0x00,0x3C,0x42,0x42,0x04,0x18,0x04,0x02,0x02,0x42,0x44,0x38,0x00,0x00},	//3
    {0x00,0x00,0x00,0x04,0x0C,0x14,0x24,0x24,0x44,0x44,0x7E,0x04,0x04,0x1E,0x00,0x00},	//4
    {0x00,0x00,0x00,0x7E,0x40,0x40,0x40,0x58,0x64,0x02,0x02,0x42,0x44,0x38,0x00,0x00},	//5
    {0x00,0x00,0x00,0x1C,0x24,0x40,0x40,0x58,0x64,0x42,0x42,0x42,0x24,0x18,0x00,0x00},	//6
    {0x00,0x00,0x00,0x7E,0x44,0x44,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00},	//7
    {0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x24,0x18,0x24,0x42,0x42,0x42,0x3C,0x00,0x00},	//8
    {0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x26,0x1A,0x02,0x02,0x24,0x38,0x00,0x00}	//9
};

unsigned char word[WORD_DATA_HEIGTH][WORD_DATA_WIDTH] = {
    /*   温        度		:	0	0   .	  0	      ℃	*/
    {0x00,0x00, 0x01,0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x60,0x00},
    {0x23,0xF8, 0x00,0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x91,0xF4},
    {0x12,0x08, 0x3F,0xFE, 0x00,  0x00, 0x00, 0x00, 0x00, 0x96,0x0C},
    {0x12,0x08, 0x22,0x20, 0x00,  0x18, 0x18, 0x00, 0x18, 0x6C,0x04},
    {0x83,0xF8, 0x22,0x20, 0x00,  0x24, 0x24, 0x00, 0x24, 0x08,0x04},
    {0x42,0x08, 0x3F,0xFC, 0x00,  0x42, 0x42, 0x00, 0x42, 0x08,0x00},
    {0x42,0x08, 0x22,0x20, 0x18,  0x42, 0x42, 0x00, 0x42, 0x18,0x00},
    {0x13,0xF8, 0x22,0x20, 0x18,  0x42, 0x42, 0x00, 0x42, 0x18,0x00},
    {0x10,0x00, 0x23,0xE0, 0x00,  0x42, 0x42, 0x00, 0x42, 0x18,0x00},
    {0x27,0xFC, 0x20,0x00, 0x00,  0x42, 0x42, 0x00, 0x42, 0x18,0x00},
    {0xE4,0xA4, 0x2F,0xF0, 0x00,  0x42, 0x42, 0x00, 0x42, 0x18,0x00},
    {0x24,0xA4, 0x24,0x10, 0x00,  0x42, 0x42, 0x00, 0x42, 0x08,0x00},
    {0x24,0xA4, 0x42,0x20, 0x18,  0x24, 0x24, 0x60, 0x24, 0x0C,0x04},
    {0x24,0xA4, 0x41,0xC0, 0x18,  0x18, 0x18, 0x60, 0x18, 0x06,0x08},
    {0x2F,0xFE, 0x86,0x30, 0x00,  0x00, 0x00, 0x00, 0x00, 0x01,0xF0},
    {0x00,0x00, 0x38,0x0E, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00,0x00},

    /*   湿        度	    :	   0	  0	.   0	  0	   %	*/
    {0x00,0x00, 0x01,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00},
    {0x27,0xF8, 0x00,0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00},
    {0x14,0x08, 0x3F,0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00},
    {0x14,0x08, 0x22,0x20, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x44,0x00},
    {0x87,0xF8, 0x22,0x20, 0x00, 0x24, 0x24, 0x00, 0x24, 0x24, 0xA4,0x00},
    {0x44,0x08, 0x3F,0xFC, 0x00, 0x42, 0x42, 0x00, 0x42, 0x42, 0xA8,0x00},
    {0x44,0x08, 0x22,0x20, 0x18, 0x42, 0x42, 0x00, 0x42, 0x42, 0xA8,0x00},
    {0x17,0xF8, 0x22,0x20, 0x18, 0x42, 0x42, 0x00, 0x42, 0x42, 0xA8,0x00},
    {0x11,0x20, 0x23,0xE0, 0x00, 0x42, 0x42, 0x00, 0x42, 0x42, 0x54,0x00},
    {0x21,0x20, 0x20,0x00, 0x00, 0x42, 0x42, 0x00, 0x42, 0x42, 0x1A,0x00},
    {0xE9,0x24, 0x2F,0xF0, 0x00, 0x42, 0x42, 0x00, 0x42, 0x42, 0x2A,0x00},
    {0x25,0x28, 0x24,0x10, 0x00, 0x42, 0x42, 0x00, 0x42, 0x42, 0x2A,0x00},
    {0x23,0x30, 0x42,0x20, 0x18, 0x24, 0x24, 0x60, 0x24, 0x24, 0x2A,0x00},
    {0x21,0x20, 0x41,0xC0, 0x18, 0x18, 0x18, 0x60, 0x18, 0x18, 0x44,0x00},
    {0x2F,0xFE, 0x86,0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00},
    {0x00,0x00, 0x38,0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00},

    /*   光         照	    :	   0	0     0		  L	 u     x	*/
    {0x01,0x00, 0x01,0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00},
    {0x21,0x08, 0x00,0x80, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00},
    {0x11,0x08, 0x3F,0xFE, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00},
    {0x09,0x10, 0x22,0x20, 0x00, 0x18, 0x18, 0x18,  0xE0, 0x00, 0x00},
    {0x09,0x20, 0x22,0x20, 0x00, 0x24, 0x24, 0x24,  0x40, 0x00, 0x00},


    {0x01,0x00, 0x3F,0xFC, 0x00, 0x42, 0x42, 0x42,  0x40, 0x00, 0x00},
    {0xFF,0xFE, 0x22,0x20, 0x18, 0x42, 0x42, 0x42,  0x40, 0x00, 0x00},
    {0x04,0x40, 0x22,0x20, 0x18, 0x42, 0x42, 0x42,  0x40, 0xC6, 0x6E},
    {0x04,0x40, 0x23,0xE0, 0x00, 0x42, 0x42, 0x42,  0x40, 0x42, 0x24},
    {0x04,0x40, 0x20,0x00, 0x00, 0x42, 0x42, 0x42,  0x40, 0x42, 0x18},
    {0x04,0x40, 0x2F,0xF0, 0x00, 0x42, 0x42, 0x42,  0x40, 0x42, 0x18},
    {0x08,0x42, 0x24,0x10, 0x00, 0x42, 0x42, 0x42,  0x40, 0x42, 0x18},
    {0x08,0x42, 0x42,0x20, 0x18, 0x24, 0x24, 0x24,  0x42, 0x46, 0x24},
    {0x10,0x42, 0x41,0xC0, 0x18, 0x18, 0x18, 0x18,  0xFE, 0x3B, 0x76},
    {0x20,0x3E, 0x86,0x30, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00},
    {0xC0,0x00, 0x38,0x0E, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00}
};
int update_word(int m0_tem, int m0_hum, int m0_lig)
{
    int line, list;					//行列

    int tmp = m0_tem;				//温度
    int hum = m0_hum;		                //湿度
    int light = m0_lig;			//光照
    int uint = 0, decade = 0, hundreds = 0;		//个位，十位，百位
    //修改温度值
    uint = tmp % 10;
    decade = tmp / 10;
    //printf("uint = %d, decade = %d\r\n", uint, decade);
    for(list = 5; list < 7; list++)
    {
	for(line = 0; line < 16; line++)
	{
	    switch(list)
	    {
		case 5:
		    {
			word[line][list] = word_all[decade][line];
		    }break;

		case 6:
		    {
			word[line][list] = word_all[uint][line];
		    }break;

		default:	;
	    }
	}
    }


    //修改湿度值
    uint = hum % 10;
    decade = hum / 10;
    for(list = 5; list < 7; list++)
    {
	for(line = 16; line < 32; line++)
	{
	    switch(list)
	    {
		case 5:
		    {
			word[line][list] = word_all[decade][line - 16];
		    }break;

		case 6:
		    {
			word[line][list] = word_all[uint][line - 16];
		    }break;

		default:	;
	    }
	}
    }


    //修改光照度
    uint = light % 10;
    decade = light % 100 / 10;
    hundreds = light / 100;
    for(list = 5; list < 8; list++)
    {
	for(line = 32; line < 48; line++)
	{
	    switch(list)
	    {
		case 5:
		    {
			word[line][list] = word_all[hundreds][line - 32];
		    }break;

		case 6:
		    {
			word[line][list] = word_all[decade][line - 32];
		    }break;

		case 7:
		    {
			word[line][list] = word_all[uint][line - 32];
		    }break;

		default:	;
	    }
	}
    }

    return 0;
}


void show_info(void)
{
    int word_line_y = WORD_DATA_HEIGTH - 1;		//三行文字最底端的行	
    int text_offset = 2560;
    int word_line_x ;				//三行文字最左端的列
    unsigned char data = 0, one=0;
    unsigned int tmp =0;  
    long int location = 0; 
    while(word_line_y--)
    {
	int word_x =0;

	for(word_line_x = 0; word_line_x < WORD_DATA_WIDTH; word_line_x++)
	{
	    //读字模
	    data = word[word_line_y][word_line_x];
	    one = 0x80;
	    int k;
	    for(k = 0; k < BIT_WIDTH; k++)
	    {
		tmp = 0;

		//确定有效位
		if(data & one)	
		    tmp = 0xFFFFFFFF;	//白色字体
		//one >>= 1;
		else
		    tmp = 0;

		location = word_line_y * (xres * bits_per_pixel / 8 ) + text_offset +word_x * (bits_per_pixel/8);
		*((unsigned long *)(fbp + location)) = tmp;
		one >>= 1;
		word_x++;

	    }
	}
    }
    return ;
}
